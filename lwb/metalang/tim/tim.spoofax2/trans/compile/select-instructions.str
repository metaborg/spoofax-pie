module compile/select-instructions

imports

  signatures/tim/-
  signatures/tim-sig
  compile/explicate-globals
  compile/string

rules

  select-instructions : TProgram(TExpLet(globals, TExpFix(funs, body))) ->
  $[[<map(select-constant)> globals]
    [<map(select-function)> funs]
    [<select-function> TFun("start", [], body)]
    ]
  select-instructions : TProgram(body) -> 
    <select-function> TFun("start", [], body)
  
  select-constant : TBind(var, TValueString(value)) ->
  $<@<var> = private unnamed_addr constant [<length> x i8] c"<str>"
  >
  with (length, str) := <process-string> value
  
  select-function : TFun(name, args, body) ->
  $[define tailcc void @[name]([<select-args> args]) nounwind {
    [<select-exp> body]
  }
  ]

  select-args : [arg] -> $[i64 %[arg]]
  select-args : [arg|args] -> $[i64 %[arg], [<select-args> args]]
  where <not(eq)> (args, [])
  select-args : [] -> $[]

  select-call-args : [arg] -> $[i64 [<select-value> arg]]
  select-call-args : [arg|args] -> $[i64 [<select-value> arg], [<select-call-args> args]]
  where <not(eq)> (args, [])
  select-call-args : [] -> $[]

  select-exp : TExpPrimOp(op, args, result, cont) ->
  $[[<select-primop(|result)> (op, args)]
    [<select-exp> cont]]
  
  select-exp : TExpTerminatingPrimOp(op, args) ->
  $[[<select-primop(|<newname>)> (op, args)]
    ret void
  ]
  
  select-exp : TExpConditionalPrimOp(op, [a1, a2], b1, b2) ->
  $[%[tmp] = icmp [cond] i64 [<select-value> a1], [<select-value> a2]
  br i1 %[tmp], label %[l1], label %[l2]
  [l1]:
  [<select-exp> b1]
  [l2]:
  [<select-exp> b2]]
  where cond := <select-int-condition> op
  with
    tmp := <newname> "result"
  ; l1 := <newname> "If"
  ; l2 := <newname> "Else"
  select-exp : TExpConditionalPrimOp(op, args, b1, b2) -> $[]
  where with(fail|"String comparison not yet implemented")  // TODO
  
  select-exp : TExpApp(TValueVar(x), args) ->
  $[%[tmp] = inttoptr i64 %[x] to ptr
  musttail call tailcc void %[tmp]([<select-call-args> args])
  ret void]
  with tmp := <newname> "ptr"
  select-exp : TExpApp(TValueGlobal(x), args) ->
  $[musttail call tailcc void @[x]([<select-call-args> args])
  ret void]
  with tmp := <newname> "ptr"
  
  select-exp = {e : ?e ; with(fail|$[unsupported exp [e]]) }

  select-int-condition : "int-eq" -> "eq"
  select-int-condition : "int-neq" -> "ne"
  select-int-condition : "int-leq" -> "sle"
  select-int-condition : "int-geq" -> "sge"
  select-int-condition : "int-lt" -> "slt"
  select-int-condition : "int-gt" -> "sgt"

  // Integer primops
  select-primop(|result) : ("int-neg", [a]) ->
  $[%[result] = sub nsw i64 0, [<select-value> a]]
  select-primop(|result) : ("int-add", [a, b]) ->
  $[%[result] = add nsw i64 [<select-value> a], [<select-value> b]]
  select-primop(|result) : ("int-sub", [a, b]) ->
  $[%[result] = sub nsw i64 [<select-value> a], [<select-value> b]]
  select-primop(|result) : ("int-mul", [a, b]) ->
  $[%[result] = mul nsw i64 [<select-value> a], [<select-value> b]]
  select-primop(|result) : ("int-div", [a, b]) ->
  $[%[result] = sdiv i64 [<select-value> a], [<select-value> b]]

  // References
  select-primop(|result) : ("ref-new", [v]) ->
  $[%[tmp] = call ptr @malloc(i64 8)
  store i64 [<select-value> v], ptr %[tmp]
  %[result] = ptrtoint ptr %[tmp] to i64]
  with
    tmp := <newname> result
  select-primop(|result) : ("ref-fetch", [ref]) ->
  $[%[tmp] = inttoptr i64 [<select-value> ref] to ptr
  %[result] = load i64, ptr %[tmp]]
  with
    tmp := <newname> "ptr"
  select-primop(|result) : ("ref-store", [ref, v]) ->
  $[%[tmp] = inttoptr i64 [<select-value> ref] to ptr
  store i64 [<select-value> v], ptr %[tmp]
  %[result] = add i64 [<select-value> v], 0]
  with
    tmp := <newname> "ptr"
  
  // Arrays
  select-primop(|result) : ("array-new", args) ->
  $[%[sizepvar] = getelementptr i64, ptr null, i64 [n]
  %[sizevar] = ptrtoint ptr %[sizepvar] to i64
  %[tmp] = call ptr @malloc(i64 %[sizevar])
  [stores]
  %[result] = ptrtoint ptr %[tmp] to i64
  ]
  with
    n := <length> args
  ; sizepvar := <newname> "sizep"
  ; sizevar := <newname> "size"
  ; tmp := <newname> result
  ; let apply(|i) = array-new-store(|tmp, i) in
      stores := <nmap(apply|0) ; concat-strings> args
    end

  array-new-store(|arr, i) : v ->
  $[%[offset] = getelementptr i64, ptr %[arr], i64 [i]
  store i64 [<select-value> v], ptr %[offset]
  ]
  with offset := <newname> "offset"
  
  select-primop(|result) : ("array-read", [arr, index]) ->
  $[%[tmpvar] = inttoptr i64 [<select-value> arr] to ptr
  %[offset] = getelementptr i64, ptr %[tmpvar], i64 [<select-value> index]
  %[result] = load i64, ptr %[offset]
  ]
  with
    tmpvar := <newname>
  ; offset := <newname> "offset"
  
  select-primop(|result) : ("array-write", [arr, index, value]) ->
  $[%[tmpvar] = inttoptr i64 [<select-value> arr] to ptr
  %[offset] = getelementptr i64, ptr %[tmpvar], i64 [<select-value> index]
  store i64 [<select-value> value], ptr %[offset]
  %[result] = add i64 [<select-value> value], 0
  ]
  with
    tmpvar := <newname>
  ; offset := <newname> "offset"

  // Print
  select-primop(|result) : ("print", [a]) ->
  $[call i32 @printf(ptr @.str_fmt, i64 [a'])
    %[result] = add i64 [a'], 0]
  with a' := <select-value> a
  // Exit
  select-primop(|_) : ("exit", []) -> 
  $[call void @exit(i32 0) noreturn
    unreachable]

  select-value : TValueVar(x) -> $[%[x]]
  select-value : TValueGlobal(x) -> $[ptrtoint (ptr @[x] to i64)]
  select-value : TValueInt(x) -> x
  select-value : TValueString(_) -> $[]
  where with(fail|"Strings not yet implemented")

  get-type : TValueVar(_) -> $[i64]  // TODO