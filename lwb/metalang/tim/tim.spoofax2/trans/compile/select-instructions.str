module compile/select-instructions

imports

  signatures/tim/-
  signatures/tim-sig
  signatures/llvm/-
  signatures/llvm-sig
  compile/explicate-globals
  compile/string

rules

  select-instructions : TProgram(TExpLet(globals, TExpFix(funs, body))) ->
    LLVMProgram(<concat> [
      <map(select-constant)> globals
    , <map(select-function)> funs
    , [<select-function> TFun("start", [], body)]
    ])
  select-instructions : TProgram(body) -> 
    <select-function> TFun("start", [], body)
  
  select-constant : TBind(var, TValueString(value)) ->
    GlobalDef(Constant(var), Private(), [UnnamedAddr(), Constant()], type, String(str))
  with
    (length, str) := <process-string> value
  ; type := Array(<int-to-string> length, Int8())
  
  select-function : TFun(name, args, body) ->
    FunDef(Private(), TailCConv(), Void(), Constant(name), args', [NoUnwind()], blocks)
  with {| Blocks
  : args' := <select-args> args
  ; (stmts, term) := <select-exp> body
  ; mainblock := Block(NoLabel(), stmts, term)
  ; otherblocks := <bagof-Blocks> ()
  ; blocks := [mainblock|otherblocks]
  |}

  select-args = map(\arg -> ParamNamed(Int64(), Variable(arg), [])\)

  select-call-args = map(\arg -> TypedAtom(Int64(), <select-value> arg)\)

  create-block(|label) : body -> ()
  with
    (stmts, term) := <select-exp> body
  ; rules(Blocks :+ () -> Block(label, stmts, term))

  select-exp : TExpPrimOp(op, args, result, cont) ->
    (<conc> (stmts1, stmts2), term)
  with
    stmts1 := <select-primop(|Variable(result))> (op, args)
  ; (stmts2, term) := <select-exp> cont
  
  select-exp : TExpTerminatingPrimOp(op, args) ->
    <select-terminating-primop> (op, args)
  
  select-exp : TExpConditionalPrimOp(op, [a1, a2], b1, b2) ->
    ( [Assign(tmp, ICmp(cond, Int64(), <select-value> a1, <select-value> a2))]
    , BrCond(TypedAtom(Bool(), VarAtom(tmp)), VarAtom(Variable(l1)), VarAtom(Variable(l2)))
    )
  where cond := <select-int-condition> op
  with
    tmp := Variable(<newname> "result")
  ; l1 := <newname> "If"
  ; l2 := <newname> "Else"
  ; <create-block(|Label(l1))> b1
  ; <create-block(|Label(l2))> b2
  select-exp : TExpConditionalPrimOp(op, args, b1, b2) -> ()
  where with(fail|"String comparison not yet implemented")  // TODO
  
  select-exp : TExpApp(TValueVar(x), args) ->
    ( [ Assign(tmp, IntToPtr(TypedAtom(Int64(), VarAtom(Variable(x))), Pointer()))
      , Expression(Call(MustTail(), TailCConv(), Void(), VarAtom(tmp), <select-call-args> args, []))
      ]
    , RetVoid()
    )
  with tmp := Variable(<newname> "ptr")
  select-exp : TExpApp(TValueGlobal(x), args) ->
    ( [Expression(Call(MustTail(), TailCConv(), Void(), ConstAtom(Constant(x)), <select-call-args> args, []))]
    , RetVoid()
    )
  
  select-exp = with(fail|$[unsupported exp])

  select-int-condition : "int-eq" -> Equal()
  select-int-condition : "int-neq" -> NotEqual()
  select-int-condition : "int-leq" -> SignedLessEqual()
  select-int-condition : "int-geq" -> SignedGreaterEqual()
  select-int-condition : "int-lt" -> SignedLessThan()
  select-int-condition : "int-gt" -> SignedGreaterThan()

  // Integer primops
  select-primop(|result) : ("int-neg", [a]) ->
    [Assign(result, BinaryOp(Sub(), [NoSignedWrap()], Int64(), Literal(Int("0")), <select-value> a))]
  select-primop(|result) : ("int-add", [a, b]) ->
    [Assign(result, BinaryOp(Add(), [NoSignedWrap()], Int64(), <select-value> a, <select-value> b))]
  select-primop(|result) : ("int-sub", [a, b]) ->
    [Assign(result, BinaryOp(Sub(), [NoSignedWrap()], Int64(), <select-value> a, <select-value> b))]
  select-primop(|result) : ("int-mul", [a, b]) ->
    [Assign(result, BinaryOp(Mul(), [NoSignedWrap()], Int64(), <select-value> a, <select-value> b))]
  select-primop(|result) : ("int-div", [a, b]) ->
    [Assign(result, BinaryOp(SDiv(), [], Int64(), <select-value> a, <select-value> b))]

  // References
  select-primop(|result) : ("ref-new", [v]) ->
    [ Assign(tmp, Call(DefaultTail(), DefaultCConv(), Pointer(), ConstAtom(Constant("gc_alloc")), [TypedAtom(Int64(), Literal(Int("8")))], []))
    , Expression(Store(TypedAtom(Int64(), <select-value> v), TypedAtom(Pointer(), VarAtom(tmp))))
    , Assign(result, PtrToInt(TypedAtom(Pointer(), VarAtom(tmp)), Int64()))
    ]
  with
    tmp := Variable(<newname> "ptr")
  select-primop(|result) : ("ref-fetch", [ref]) ->
    [ Assign(tmp, IntToPtr(TypedAtom(Int64(), <select-value> ref), Pointer()))
    , Assign(result, Load(Int64(), TypedAtom(Pointer(), VarAtom(tmp))))
    ]
  with
    tmp := Variable(<newname> "ptr")
  select-primop(|result) : ("ref-store", [ref, v]) ->
    [ Assign(tmp, IntToPtr(TypedAtom(Int64(), <select-value> ref), Pointer()))
    , Expression(Store(TypedAtom(Int64(), <select-value> v), TypedAtom(Pointer(), VarAtom(tmp))))
    , Assign(result, BinaryOp(Add(), [], Int64(), <select-value> v, Literal(Int("0"))))
    ]
  with
    tmp := Variable(<newname> "ptr")

  // Records
  select-primop(|result) : ("record-new", args) ->
    [Assign(
       result
     , Call(
         DefaultTail()
       , DefaultCConv()
       , Function(Int64(), [ParamUnnamed(Int64(), []), Vararg()])
       , ConstAtom(Constant("record_new"))
       , [TypedAtom(Int64(), Literal(Int(count)))|<select-call-args> args]
       , []
       )
     )]
  with count := <divi ; int-to-string> (<length> args, 2)
  select-primop(|result) : ("record-write", args) ->
    [Assign(
       result
     , Call(
         DefaultTail()
       , DefaultCConv()
       , Function(Int64(), [ParamUnnamed(Int64(), []), Vararg()])
       , ConstAtom(Constant("record_write"))
       , <select-call-args> args
       , []
       )
     )]
  select-primop(|result) : ("record-read", args) ->
    [Assign(
       result
     , Call(
         DefaultTail()
       , DefaultCConv()
       , Function(Int64(), [ParamUnnamed(Int64(), []), Vararg()])
       , ConstAtom(Constant("record_read"))
       , <select-call-args> args
       , []
       )
     )]
  
  // Arrays
  select-primop(|result) : ("array-new", args) ->
    <concat> [
      [ Assign(sizepvar, GetElementPtr(Int64(), [TypedAtom(Pointer(), Literal(Null())), n]))
      , Assign(sizevar, PtrToInt(TypedAtom(Pointer(), VarAtom(sizepvar)), Int64()))
      , Assign(tmp, Call(
          DefaultTail()
        , DefaultCConv()
        , Pointer()
        , ConstAtom(Constant("gc_alloc"))
        , [TypedAtom(Int64(), VarAtom(sizevar))]
        , []
        ))
      ]
    , stores
    , [ Assign(result, PtrToInt(TypedAtom(Pointer(), VarAtom(tmp)), Int64()))]
    ]
  with
    n := TypedAtom(Int64(), Literal(Int(<length ; int-to-string> args)))
  ; sizepvar := Variable(<newname> "sizep")
  ; sizevar := Variable(<newname> "size")
  ; tmp := Variable(<newname> result)
  ; let apply(|i) = array-new-store(|tmp, i) in
      stores := <nmap(apply|0) ; concat> args
    end

  array-new-store(|arr, i) : v ->
    [ Assign(offset, GetElementPtr(Int64(), [arr', i']))
    , Expression(Store(TypedAtom(Int64(), <select-value> v), TypedAtom(Pointer(), VarAtom(offset))))
    ]
  with
    offset := Variable(<newname> "offset")
  ; arr' := TypedAtom(Pointer(), VarAtom(arr))
  ; i' := TypedAtom(Int64(), Literal(Int(<int-to-string> i)))
  
  select-primop(|result) : ("array-read", [arr, index]) ->
    [ Assign(tmpvar, IntToPtr(TypedAtom(Int64(), <select-value> arr), Pointer()))
    , Assign(offset, GetElementPtr(Int64(), [TypedAtom(Pointer(), VarAtom(tmpvar)), TypedAtom(Int64(), <select-value> index)]))
    , Assign(result, Load(Int64(), TypedAtom(Pointer(), VarAtom(offset))))
    ]
  with
    tmpvar := Variable(<newname> "ptr")
  ; offset := Variable(<newname> "offset")
  
  select-primop(|result) : ("array-write", [arr, index, value]) ->
    [ Assign(tmpvar, IntToPtr(TypedAtom(Int64(), <select-value> arr), Pointer()))
    , Assign(offset, GetElementPtr(Int64(), [TypedAtom(Pointer(), VarAtom(tmpvar)), TypedAtom(Int64(), <select-value> index)]))
    , Expression(Store(TypedAtom(Int64(), <select-value> value), TypedAtom(Pointer(), VarAtom(offset))))
    , Assign(result, BinaryOp(Add(), [], Int64(), <select-value> value, Literal(Int("0"))))
    ]
  with
    tmpvar := Variable(<newname> "ptr")
  ; offset := Variable(<newname> "offset")

  // Closures
  select-primop(|result) : ("closure-new", args) ->
    <concat> [
      [ Assign(sizepvar, GetElementPtr(Int64(), [TypedAtom(Pointer(), Literal(Null())), n]))
      , Assign(sizevar, PtrToInt(TypedAtom(Pointer(), VarAtom(sizepvar)), Int64()))
      , Assign(tmp, Call(
          DefaultTail()
        , DefaultCConv()
        , Pointer()
        , ConstAtom(Constant("gc_alloc"))
        , [TypedAtom(Int64(), VarAtom(sizevar))]
        , []
        ))
      ]
    , stores
    , [ Assign(result, PtrToInt(TypedAtom(Pointer(), VarAtom(tmp)), Int64()))]
    ]
  with
    n := TypedAtom(Int64(), Literal(Int(<length ; int-to-string> args)))
  ; sizepvar := Variable(<newname> "sizep")
  ; sizevar := Variable(<newname> "size")
  ; tmp := Variable(<newname> result)
  ; let apply(|i) = array-new-store(|tmp, i) in
      stores := <nmap(apply|0) ; concat> args
    end

  closure-new-store(|arr, i) : v ->
    [ Assign(offset, GetElementPtr(Int64(), [arr', i']))
    , Expression(Store(TypedAtom(Int64(), <select-value> v), TypedAtom(Pointer(), VarAtom(offset))))
    ]
  with
    offset := Variable(<newname> "offset")
  ; arr' := TypedAtom(Pointer(), VarAtom(arr))
  ; i' := TypedAtom(Int64(), Literal(Int(<int-to-string> i)))
  
  select-primop(|result) : ("closure-read", [arr, index]) ->
    [ Assign(tmpvar, IntToPtr(TypedAtom(Int64(), <select-value> arr), Pointer()))
    , Assign(offset, GetElementPtr(Int64(), [TypedAtom(Pointer(), VarAtom(tmpvar)), TypedAtom(Int64(), <select-value> index)]))
    , Assign(result, Load(Int64(), TypedAtom(Pointer(), VarAtom(offset))))
    ]
  with
    tmpvar := Variable(<newname> "ptr")
  ; offset := Variable(<newname> "offset")
  
  select-primop(|result) : ("closure-offset", [arr, index]) ->
    [ Assign(tmpvar, IntToPtr(TypedAtom(Int64(), <select-value> arr), Pointer()))
    , Assign(offset, GetElementPtr(Int64(), [TypedAtom(Pointer(), VarAtom(tmpvar)), TypedAtom(Int64(), <select-value> index)]))
    , Assign(result, PtrToInt(TypedAtom(Pointer(), VarAtom(offset)), Int64()))
    ]
  with
    tmpvar := Variable(<newname> "ptr")
  ; offset := Variable(<newname> "offset")

  // Print
  select-primop(|result) : ("print-int", [a]) ->
    [ Expression(
        Call(
          DefaultTail()
        , DefaultCConv()
        , Function(Int32(), [ParamUnnamed(Pointer(), []), Vararg()])
        , ConstAtom(Constant("printf"))
        , [ TypedAtom(Pointer(), ConstAtom(Constant(".int_fmt")))
          , TypedAtom(Int64(), <select-value> a)
          ]
        , []
        )
      )
    , Assign(result, BinaryOp(Add(), [], Int64(), <select-value> a, Literal(Int("0"))))
    ]
  select-primop(|result) : ("print-string", [a]) ->
    [ Expression(
        Call(
          DefaultTail()
        , DefaultCConv()
        , Function(Int32(), [ParamUnnamed(Pointer(), []), Vararg()])
        , ConstAtom(Constant("printf"))
        , [ TypedAtom(Pointer(), ConstAtom(Constant(".str_fmt")))
          , TypedAtom(Int64(), <select-value> a)
          ]
        , []
        )
      )
    , Assign(result, BinaryOp(Add(), [], Int64(), <select-value> a, Literal(Int("0"))))
    ]
  select-primop(|result) : ("print", [a]) ->
    <with(fail|"Could not determine print type at compile time")>
  // Exit
  select-terminating-primop : ("exit", []) -> 
    ( [Expression(Call(DefaultTail(), DefaultCConv(), Void(), ConstAtom(Constant("exit")), [], [NoReturn()]))]
    , Unreachable()
    )

  select-value : TValueVar(x) -> VarAtom(Variable(x))
  select-value : TValueGlobal(x) -> PtrToInt(Constant(x), Int64())
  select-value : TValueInt(x) -> Literal(Int(x))
  select-value : TValueString(x) -> Literal(String(x))

  get-type : TValueVar(_) -> Int64()  // TODO