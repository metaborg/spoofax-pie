module compile/closure

imports

  signatures/tim-sig
  signatures/tim/-
  compile/uniquify
  compile/explicate-globals
  pp

rules

  debug-convert-closures :
    (node, _, ast, path, project-path) -> (filename, result)
    with
      ext      := <get-extension> path
    ; filename := <guarantee-extension(|$[cc.[ext]])> path
    ; result   := <strip-annos; uniquify; convert-closures; topdown(try(\TValueGlobal(x) -> TValueVar(x)\)); pp-debug> ast

  convert-closures =
    topdown(try(mark-non-escaping))
  ; topdown(try(convert-non-escaping))
  ; bottomup(try(convert-closure))
  ; bottomup(try(convert-closure-call))
  ; extract-funs
  
  mark-non-escaping : t@TExpFix(funs, body) -> t'
  where <fix-is-non-escaping> t
  with
    {| Remap
    : <map({name : ?TFun(name, _, _) ; rules(Remap : TValueVar(name) -> TValueGlobal(name))})> funs
    ; t' := <topdown(try(Remap))> t
    |}

//  convert-fix : t@TExpFix(_, _) -> t'
//  with
//    if <fix-is-non-escaping> t then
//      t' := <convert-non-escaping> t
//    else
//      t' := <convert-closure> t
//    end
  
  fix-is-non-escaping : t@TExpFix(funs, e) -> ()
  where <map(\TFun(name, _, _) -> (name, t)\ ; fun-is-non-escaping)> funs
  
  fun-is-non-escaping : (name, body) -> ()
  where not(oncetd(not(?TExpApp(TValueVar(name), _)) ; one(?TValueVar(name))))
  
  convert-non-escaping : t@TExpFix(funs, exp) -> t'
  where <fix-is-non-escaping> t
  with
    {| ConvertCall
    : funs' := <map(convert-non-escaping-fun)> funs
    ; t' := <topdown(try(ConvertCall))> TExpFix(funs', exp)
    |}

  convert-non-escaping-fun : TFun(name, args, body) -> TFun(name, args', body)
  with
    freevars := <find-free-vars(|[name|args])> body
  ; args' := <conc> (args, freevars)
  ; nonescaping-call(|name, freevars)
  
  convert-closure : t@TExpFix(funs, exp) -> t'
    where <not(fix-is-non-escaping)> t
    with
      {| ConvertCall
      : funnames@[firstname|restnames] := <map(\TFun(name, _, _) -> name\)> funs
      ; freevars := <foldr(![], union, \TFun(name, args, body) -> <find-free-vars(|<conc> (funnames, args))> body\)> funs
      ; closure := <newname> "closure"
      ; let var-to-read-exp = var-to-read-op(|funnames, freevars) in
          (names', funs') := <map(convert-fun(var-to-read-exp)) ; unzip> funs
        ; exp' := <foldr(!exp, \(name, c)-> <var-to-read-exp> (firstname, name, c)\)> restnames
        end
      ; exp'' := TExpPrimOp("closure-new", <conc ; map(!TValueVar(<id>))> (names', freevars), firstname, exp')
      ; t' := <topdown(try(ConvertCall))> TExpFix(funs', exp'')
      |}
  
  nonescaping-call(|x, freevars) = rules(
    ConvertCall : TExpApp(TValueGlobal(x), vals) -> TExpApp(TValueGlobal(x), <conc> (vals, freevars'))
    with
      freevars' := <map(!TValueVar(<id>))> freevars
  )

  convert-closure-call : TExpApp(TValueVar(x), vals) ->
    TExpPrimOp("closure-read", [TValueVar(x), TValueInt("0")], x', TExpApp(TValueVar(x'), vals'))
  with
    x' := <newname> x
  ; vals' := [TValueVar(x)|vals]

  convert-fun(var-to-read-exp|) : TFun(name, args, body) -> (name', TFun(name', args', body'))
  with
    name' := <newname> name
  ; args' := [name|args]
  ; freevars := <find-free-vars(|args')> body
  ; body' := <foldr(!body, \(v, c) -> <var-to-read-exp> (name, v, c)\)> freevars
  ; rules(
      ConvertCall : TExpApp(v@TValueVar(name), vals) -> TExpApp(TValueGlobal(name'), [v|vals])
    )

  var-to-read-op(|funs, vars) : (name, v, c) -> TExpPrimOp("closure-offset", [TValueVar(name), n], v, c)
  where idx := <fun-get-index(|funs)> v
  with
    offset := <fun-get-index(|funs)> name
  ; n := TValueInt(<subti ; int-to-string> (idx, offset))
  var-to-read-op(|funs, vars) : (name, v, c) -> TExpPrimOp("closure-read", [TValueVar(name), n], v, c)
  where idx := <var-get-index(|funs, vars)> v
  with
    offset := <fun-get-index(|funs)> name
  ; n := TValueInt(<subti ; int-to-string> (idx, offset))
  
  fun-get-index(|funs) : v -> n
  where n := <subti> (<get-index> (v, funs), 1)
  var-get-index(|funs, vars) : v -> n
  where n := <subti> (<addi> (<length> funs, <get-index> (v, vars)), 1)
  
  find-free-vars(|usedVars) : TValueInt(_) -> []
  find-free-vars(|usedVars) : TValueString(_) -> []
  find-free-vars(|usedVars) : TValueGlobal(_) -> []
  find-free-vars(|usedVars) : TValueVar(x) -> []
    where <elem> (x, usedVars)
  find-free-vars(|usedVars) : TValueVar(x) -> [x]
  find-free-vars(|usedVars) : THole() -> []
  find-free-vars(|usedVars) : TExpApp(v, vs) ->
    <foldr(![], union, find-free-vars(|usedVars))> [v|vs]
  find-free-vars(|usedVars) : TExpFix(funs, exp) -> freeVars
    with
      newVars := <map(\TFun(x, _, _) -> x\)> funs
    ; usedVars' := <conc> (usedVars, newVars)
    ; freeVars := <foldr(![], union, find-free-vars(|usedVars'))> [exp|funs]
  find-free-vars(|usedVars) : TFun(name, args, body) -> freeVars
    with
      usedVars' := <conc> ([name|args], usedVars)
    ; freeVars := <find-free-vars(|usedVars')> body
  find-free-vars(|usedVars) : TExpPrimOp(_, vals, newVar, exp) -> <union> (a, b)
    with
      a := <foldr(![], union, find-free-vars(|usedVars))> vals
    ; b := <find-free-vars(|[newVar|usedVars])> exp
  find-free-vars(|usedVars) : TExpTerminatingPrimOp(_, vals) ->
    <foldr(![], union, find-free-vars(|usedVars))> vals
  find-free-vars(|usedVars) : TExpConditionalPrimOp(_, vals, exp1, exp2) ->
    <foldr(![], union, find-free-vars(|usedVars))> [exp1, exp2|vals]
  find-free-vars(|usedVars) : TExpLet(binds, exp) -> <find-free-vars(|newVars)> exp
    with
      extraVars := <map(\TBind(x, _) -> x\)> binds
    ; newVars := <conc> (usedVars, extraVars)

  extract-funs : TProgram(exp) -> TProgram(TExpFix(funs, exp'))
    with {| Functions
    : exp' := <bottomup(try(collect-funs))> exp
    ; funs := <(bagof-Functions <+ ![])> ()
    |}
  
  collect-funs : fix@TExpFix(funs, exp) -> exp
    with <map(\x -> x with rules(Functions :+ _ -> x)\)> funs
