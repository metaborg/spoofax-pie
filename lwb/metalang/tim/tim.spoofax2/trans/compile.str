module compile

imports

  signatures/-
  pp

rules

  debug-convert-closures :
    (node, _, ast, path, project-path) -> (filename, result)
    with
      ext      := <get-extension> path
    ; filename := <guarantee-extension(|$[cc.[ext]])> path
    ; result   := <convert-closures; pp-debug> node

  convert-closures = bottomup(try(convert-closure)) ; bottomup(try(convert-calls))
  
  convert-closure : TExpFix([fun|funs], exp) -> TExpFix([fun'|funs'], exp'')
    with
      (fun', exp') := <convert-fun> (fun, exp)
    ; TExpFix(funs', exp'') := <convert-closure> TExpFix(funs, exp')
  convert-closure : TExpFix([], exp) -> TExpFix([], exp)

  convert-calls : TExpApp(TValueVar(x), vals) ->
    TExpPrimOp("array-read", [TValueVar(x), TValueInt("0")], x', TExpApp(TValueVar(x'), vals'))
    with
      x' := <newname> x
    ; vals' := [TValueVar(x)|vals]
  
  convert-fun : (TFun(name, args, exp1), exp2) -> (TFun(newName, [name|args], exp1'), exp2')
    with
      freevars := <find-free-vars(|args)> exp1
    ; <debug> freevars
    ; <debug> args
    ; newName := <newname> name
    ; exp1' := <convert-fun-body(|name, "1")> (freevars, exp1)
    ; exp2' := TExpPrimOp("array-new", <map(!TValueVar(<id>))> [newName|freevars], name, exp2)
  convert-fun-body(|argname, index) : ([v|vars], exp) ->
    TExpPrimOp("array-read", [TValueVar(argname), TValueInt(index)], v,
      <convert-fun-body(|argname, index')> (vars, exp))
  with
    index' := <addS> (index, "1")
  convert-fun-body(|argname, index) : ([], exp) -> exp
  
//  find-free-vars(|usedVars) : TExpApp
  
  find-free-vars(|usedVars) : TValueInt(_) -> []
  find-free-vars(|usedVars) : TValueString(_) -> []
  find-free-vars(|usedVars) : TValueVar(x) -> []
    where <strip-annos; elem> (x, usedVars)
  find-free-vars(|usedVars) : TValueVar(x) -> [x]
  find-free-vars(|usedVars) : THole() -> []
  find-free-vars(|usedVars) : TExpApp(v, vs) -> <flatten-list> [a, b]
    with
      a := <find-free-vars(|usedVars)> v
    ; b := <map(find-free-vars(|usedVars))> vs
  find-free-vars(|usedVars) : TExpFix(funs, exp) -> <fail>  // TODO: figure this out
  find-free-vars(|usedVars) : TExpPrimOp(_, vals, newVar, exp) -> <flatten-list> [a, b]
    with
      a := <map(find-free-vars(|usedVars))> vals
    ; b := <find-free-vars(|[newVar|usedVars])> exp
  find-free-vars(|usedVars) : TExpTerminatingPrimOp(_, vals) ->
    <with(map(find-free-vars(|usedVars)))> vals
  find-free-vars(|usedVars) : TExpConditionalPrimOp(_, vals, exp1, exp2) -> <flatten-list> [a, b, c]
    with
      a := <map(find-free-vars(|usedVars))> vals
    ; b := <find-free-vars(|usedVars)> exp1
    ; c := <find-free-vars(|usedVars)> exp2
  find-free-vars(|usedVars) : TExpLet(binds, exp) -> <find-free-vars(|newVars)> exp
    with
      extraVars := <map(\TBind(x, _) -> x\)> binds
    ; newVars := <conc> (usedVars, extraVars)
















