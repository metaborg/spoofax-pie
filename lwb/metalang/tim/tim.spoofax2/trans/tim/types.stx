module tim/types

imports
  signatures/tim/common-sig
  signatures/tim/type-sig
  tim/names
  
signature
  sorts TYPE
  constructors
    INT : TYPE
    STRING : TYPE
    FUNCTION : list(TYPE) -> TYPE
    REF : TYPE -> TYPE
    ARRAY : TYPE -> TYPE
    RECORD : TYPE -> TYPE
    CLOSURE : list(TYPE) -> TYPE
    ANONCLOSURE : TYPE
    ANY : TYPE
    STRUCT : list((TID * TYPE)) -> TYPE
    SYMBOL : TID -> TYPE
    
rules
  typeOfType : scope * TType -> TYPE
  typesOfTypes maps typeOfType(*, list(*)) = list(*)
  
  typeOfType(s, TIntT()) = INT().
  typeOfType(s, TStringT()) = STRING().
  typeOfType(s, TFunctionT(Ts)) = FUNCTION(Ts') :-
    Ts' == typesOfTypes(s, Ts).
  typeOfType(s, TRefT(T)) = REF(T') :-
    T' == typeOfType(s, T).
  typeOfType(s, TArrayT(T)) = ARRAY(T') :-
    T' == typeOfType(s, T).
  typeOfType(s, TRecordT(T)) = RECORD(T') :-
    T' == typeOfType(s, T).
  typeOfType(s, TAnonClosureT()) = ANONCLOSURE().
  typeOfType(s, TClosureT(Ts)) = CLOSURE(Ts') :-
    Ts' == typesOfTypes(s, Ts).
  typeOfType(s, TAnyT()) = ANY().
  typeOfType(s, TStructT(members)) = STRUCT(members') :-
    members' == membersOk(s, members).
  typeOfType(s, TNamedT(x)) = resolveType(s, x).
  typeOfType(s, TSymbolT(x)) = SYMBOL(x).
  typeOfType(s, TInferredT()) = T :-
    T != ANY().
  
  typeNotAny : TYPE
  typesNotAny maps typeNotAny(list(*))
  typeNotAny(T) :- T != ANY().
  
  memberOk : scope * TStructMember -> (TID * TYPE)
  membersOk maps memberOk(*, list(*)) = list(*)
  memberOk(s, TStructMember(x, T)) = (x, T') :-
    T' == typeOfType(s, T).

  typeOfMember : TYPE * TID -> TYPE
  typeOfMember(STRUCT([(x, T)|_]), x) = T :-
    @x.type := T.
  typeOfMember(STRUCT([_|tail]), x) = T :-
    T == typeOfMember(STRUCT(tail), x).
  
  printable : TYPE
  printable(INT()).
  printable(STRING()).

  // whether first argument is compatible in a context where a second
  // argument is expected
  typeCoercibleTo : TYPE * TYPE
  typesCoercibleTo maps typeCoercibleTo(list(*), list(*))
  typesCoercibleToOne maps typeCoercibleTo(list(*), *)
  
  typeCoercibleTo(T, T).
//  typeCoercibleTo(REF(T1), REF(T2)) :- 
//    elementCoercibleTo(T1, T2).
//  typeCoercibleTo(ARRAY(T1), ARRAY(T2)) :- 
//    elementCoercibleTo(T1, T2).
//  typeCoercibleTo(RECORD(T1), RECORD(T2)) :- 
//    elementCoercibleTo(T1, T2).
  typeCoercibleTo(INT(), ANY()) :-
    try { false } | note $[Boxing an integer].
  typeCoercibleTo(ANY(), INT()) :-
    try { false } | note $[Unboxing an integer].
  typeCoercibleTo(T, ANY()).
  typeCoercibleTo(ANY(), T).
  
  elementCoercibleTo : TYPE * TYPE
  elementCoercibleTo(T, T).
  elementCoercibleTo(T, ANY()) :-
    T != INT().