module refret

imports
  strategolib
  //signatures/Tiger-sig
imports
  libspoofax/analysis/constraint
  statix/runtime/analysis
  statix/runtime/ast
  
  signatures/syntax/Arrays-sig
  signatures/syntax/Base-sig
  signatures/syntax/Bindings-sig
  signatures/syntax/Control-Flow-sig
  signatures/syntax/Functions-sig
  signatures/syntax/Identifiers-sig
  signatures/syntax/Numbers-sig
  signatures/syntax/Records-sig
  signatures/syntax/Strings-sig
  signatures/syntax/Types-sig
  signatures/syntax/Variables-sig
  signatures/syntax/Whitespace-sig
  injections/-
  injections/syntax/-
  
imports //construct-textual-change
  libstratego-gpp
  libspoofax/sdf/pp
  libspoofax/editor/refactoring/-
  pp/tiger-parenthesize
  pp

strategies

  qualify-reference(|ctxs, sortName) = debug(!"Qualifying: "); ![(<id>, <rr-get-ref-index>)]; debug(!"Qualified as: ") //, (LValue2Exp(FieldVar(Var("r"), <id>)), <stx--get-ast-index>)]

  construct-textual-change = construct-textual-change(pp-partial-tiger-string, parenthesize, override-reconstruction, resugar)

  inline-method-call(|call@Call(name, args), solverResultTerm): ast -> text
  where where(<debug(!"Call: ")> call);
  		explicatedCall := <explicate-injections-tiger-Exp> call;										// Explicate call, because we only work with explicated ASTs
  		where(<debug(!"Explicated Call: ")> explicatedCall);
  		analysis := <stx--get-ast-analysis> ast;														// Get the original analysis
  		explicatedAst := <explicate-injections-tiger> ast;												// Explicate the full AST, because we only work with explicated ASTs
        decl := <stx--get-ast-property(|analysis, Ref())> name;											// Get the declaration term the reference is pointing to (@ref attribute)
        fun@FunDec(fname, fparams, fretType, fbody) := <collect(?FunDec(_,_,_,_)|decl)> explicatedAst;	// Get the function definition corresponding to the declaration term
        where(<debug(!"Inlining: ")> fun);
        
        newbody := <rr-lock-all-references(|analysis, solverResultTerm)> fbody;							// Lock all references in the function body
        ctxs := <build-contexts(|explicatedCall, solverResultTerm)> explicatedAst;						// Build the contexts
        plhdrbody := <prim("RR_create_placeholder", ctxs)> newbody;										// Build the placeholder for the inlined function body
        argvars := <zip(?(FArg(pn, pty), ae); !VarDec(pn, pty, <explicate-injections-tiger-Exp> ae))> (fparams, args);					// Construct variable definitions from the parameters and call arguments
        replacement := Let(argvars, [ plhdrbody ]);														// Build the AST surrounding the inlined function body
        newAst := <replace(!replacement|explicatedCall)> explicatedAst;									// Replace the old call with the new AST
        where(<debug(!"Pre-RR: ")> newAst);
        fixedAst := <prim("RR_fix_references", solverResultTerm)> newAst;								// Fix references inside the placeholders
        where(<debug(!"Post-RR: ")> fixedAst);
        implicatedAst := <implicate-injections-tiger> fixedAst;  										// Implicate the final (fixed) AST
        where(<debug(!"Implicated: ")> implicatedAst);
        text := <pp-into-existing> (ast, implicatedAst);
        where(<debug(!"Text: ")> text)
        
        
   // Pretty-prints the changed AST into the existing code,
   // or as a fallback performs pretty-printing on the whole AST.
   pp-into-existing = ?(_, <id>); pp-tiger-string
   // pp-into-existing: (oldAst, newAst) -> newText
   //where newText := <catch-with(
   //		 	construct-textual-change; ?(_, _, <id>),		// FIXME: Sometimes fails with NullPointerException because a Token doesn't have a Tokenizer, after building the language but before the file with the inlining source is (re-)saved
   //		 	?(_, (_, <id>), _); pp-tiger-string
	// 	 )> (oldAst, newAst)
        
        
   build-contexts(|call@Call(_, _), solverResultTerm): ast -> [] // Not sure what contexts we could provide here
   
        
   // Finds the declaration term corresponding to the specified declaration
   // (that was retrieved from the @ref attribute of a reference)
   collect(s|decl) =
     where(idx := <stx--get-ast-index> decl);
     collect-onebu(s; has-index(|idx))
     
   // Replaces a term in the ast that matches the given term and its index
   // by applying strategy s to it
   replace(s|term) =
     where(<debug(!"Replace: ")> term);
     where(idx := <stx--get-ast-index> term);
     where(<debug(!"Replace idx: ")> idx);
     where(debug(!"Replace in: "));
     where(s; debug(!"Replace with: "));
     oncebu(debug(!"A: "); ?term; debug(!"B: "); where(stx--get-ast-index; ?idx); debug(!"C: "); s; debug(!"D: "))
   
   // Succeeds if the term has a subterm with the specified index
   has-index(|idx): term -> term
   where oncetd(stx--get-ast-index; ?idx)
  
  // Collect bottomup the first term where strategy `s` succeeds; or fails if there is no such term
  collect-onebu(s) = oncebu(where(s; ?t)); !t

  // Locks all references in the given term
  rr-lock-all-references(|analysis, solverResultTerm) = bottomup(try(rr-lock-one-reference(|analysis, solverResultTerm)))

  // Locks the reference represented by the given term
  // if the reference has a @ref property, or fails if it is not a reference.
  //rr-lock-one-reference(|analysis, solverResultTerm): ref -> lockedRef
  //where decl := <stx--get-ast-property(|analysis, Ref())> ref;
  //      where(<debug(!"Accept Decl: ")> decl);
  //      lockedRef := <prim("RR_lock_reference", decl, solverResultTerm)> ref;
  //      where(<debug(!"Locked: ")> lockedRef)
        
  rr-lock-one-reference(|analysis, solverResultTerm): ref -> lockedRef
  where (name, sortName) := <rr-get-ref-name> ref;	// Fails if the term is not a valid reference
        decl := <stx--get-ast-property(|analysis, Ref())> name;
        where(<debug(!"Accept Decl: ")> decl);
        lockedRef := <prim("RR_lock_reference", decl, solverResultTerm, sortName)> ref;
        where(<debug(!"Locked: ")> lockedRef)
        
  // If the term is a valid reference, returns the name and the sort name
  // Otherwise, fails
  rr-get-ref-name: LValue2Exp(Var2LValue(Var(name))) -> (name, "Exp")
  // If the term is a valid reference, returns the term index.
  rr-get-ref-index: LValue2Exp(Var2LValue(Var(name))) -> <stx--get-ast-index> name


