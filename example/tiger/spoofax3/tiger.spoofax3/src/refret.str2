module refret

imports
  strategolib
  //signatures/Tiger-sig
imports
  libspoofax/analysis/constraint
  statix/runtime/analysis
  statix/runtime/ast
  
  signatures/syntax/Arrays-sig
  signatures/syntax/Base-sig
  signatures/syntax/Bindings-sig
  signatures/syntax/Control-Flow-sig
  signatures/syntax/Functions-sig
  signatures/syntax/Identifiers-sig
  signatures/syntax/Numbers-sig
  signatures/syntax/Records-sig
  signatures/syntax/Strings-sig
  signatures/syntax/Types-sig
  signatures/syntax/Variables-sig
  signatures/syntax/Whitespace-sig
  injections/-
  injections/syntax/-
  
imports //construct-textual-change
  libstratego-gpp
  libspoofax/sdf/pp
  libspoofax/editor/refactoring/-
  pp/tiger-parenthesize
  pp

strategies

  qualify-reference(|ctxs, sortName) = debug(!"Qualifying: "); ![(<id>, <rr-get-ref-index>)]; debug(!"Qualified as: ") //, (LValue2Exp(FieldVar(Var("r"), <id>)), <stx--get-ast-index>)]

  construct-textual-change = construct-textual-change(pp-partial-tiger-string, parenthesize, override-reconstruction, resugar)

  inline-method-call(|call@Call(name, args), solverResultTerm): ast -> text
  where // Boilerplate preprocessing
        where(<debug(!"Call: ")> call);
  		explicatedCall := <explicate-injections-tiger-Exp> call;										// Explicate call, because we only work with explicated ASTs
  		where(<debug(!"Explicated Call: ")> explicatedCall);
  		analysis := <stx--get-ast-analysis> ast;														// Get the original analysis
  		explicatedAst := <explicate-injections-tiger> ast;												// Explicate the full AST, because we only work with explicated ASTs
  		
  		///////////////////////
  		// Refactoring Start //
  		///////////////////////
  		
  		// Find method definition
        decl := <stx--get-ast-property(|analysis, Ref())> name;											// Get the declaration term the reference is pointing to (@ref attribute)
        fun@FunDec(fname, fparams, fretType, fbody) := <collect(?FunDec(_,_,_,_)|decl)> explicatedAst;	// Get the function definition corresponding to the declaration term
        where(<debug(!"Inlining: ")> fun);
        
        // Replace method call with built inlined code, with fix references wrapped in a RR placeholder
        max-index := </*stx--get-max-ast-index*/ !255> ast;														// Get the maximum AST index
        (reindexedBody, map) := <rr-reindex(|max-index)> fbody;						    				// Reindexes the body that is being moved (this must happen before locking references)
        newBody := <rr-lock-all-references(|analysis, solverResultTerm, map)> fbody;					// Lock all references in the function body
        ctxs := <build-contexts(|explicatedCall, solverResultTerm)> explicatedAst;						// Build the contexts (e.g. receiver)
        
        reindexedNewBody := <rr-reindex(|max-index)> newBody;											// Reindex the new function body
        plhdrbody := <rr--create-placeholder(|ctxs)> reindexedNewBody;		      	                 	// Build the placeholder for the inlined function body
        argvars := <zip(?(FArg(pn, pty), ae); !VarDec(pn, pty, <explicate-injections-tiger-Exp> ae))> (fparams, args);					// Construct variable definitions from the parameters and call arguments
        replacement := Let(argvars, [ plhdrbody ]);														// Build the AST surrounding the inlined function body
        newAst := <replace(!replacement|explicatedCall)> explicatedAst;									// Replace the old call with the new AST
        
        // Unwrap placeholder and fix references
        where(<debug(!"Pre-RR: ")> newAst);
        fixedAst := <rr--fix-references(|solverResultTerm)> newAst;								        // Fix references inside the placeholders
        where(<debug(!"Post-RR: ")> fixedAst);
        
        ///////////////////////
        //  Refactoring End  //
        ///////////////////////
        
        // Boilerplate postprocessing
        implicatedAst := <implicate-injections-tiger> fixedAst;  										// Implicate the final (fixed) AST
        where(<debug(!"Implicated: ")> implicatedAst);
        text := <pp-into-existing> (ast, implicatedAst);
        where(<debug(!"Text: ")> text)
        
        
   // Pretty-prints the changed AST into the existing code,
   // or as a fallback performs pretty-printing on the whole AST.
   pp-into-existing = ?(_, <id>); pp-tiger-string
   // pp-into-existing: (oldAst, newAst) -> newText
   //where newText := <catch-with(
   //		 	construct-textual-change; ?(_, _, <id>),		// FIXME: Sometimes fails with NullPointerException because a Token doesn't have a Tokenizer, after building the language but before the file with the inlining source is (re-)saved
   //		 	?(_, (_, <id>), _); pp-tiger-string
	// 	 )> (oldAst, newAst)
        
        
   build-contexts(|call@Call(_, _), solverResultTerm): ast -> [] // Not sure what contexts we could provide here
   
        
   // Finds the declaration term corresponding to the specified declaration
   // (that was retrieved from the @ref attribute of a reference)
   collect(s|decl) =
     where(idx := <stx--get-ast-index> decl);
     collect-onebu(s; has-index(|idx))
     
   // Replaces a term in the ast that matches the given term and its index
   // by applying strategy s to it
   replace(s|term) =
     where(<debug(!"Replace: ")> term);
     where(idx := <stx--get-ast-index> term);
     where(<debug(!"Replace idx: ")> idx);
     where(debug(!"Replace in: "));
     where(s; debug(!"Replace with: "));
     oncebu(debug(!"A: "); ?term; debug(!"B: "); where(stx--get-ast-index; ?idx); debug(!"C: "); s; debug(!"D: "))
   
   // Succeeds if the term has a subterm with the specified index
   has-index(|idx): term -> term
   where oncetd(stx--get-ast-index; ?idx)
  
  // Collect bottomup the first term where strategy `s` succeeds; or fails if there is no such term
  collect-onebu(s) = oncebu(where(s; ?t)); !t

  // Locks all references in the given subtree, by traversing the subtree and finding all terms
  // with a @ref property. The locked reference wraps the term and stores the declaration the
  // reference resolves to (as a term index).
  // The map may contain a mapping from the original term index to the new term index;
  // or alternatively, provide an empty map if this is not necessary/computed: <immap-new>
  rr-lock-all-references(|analysis, solverResultTerm, map) = bottomup(try(rr-lock-one-reference(|analysis, solverResultTerm, map)))
//  rr-lock-all-references(|analysis, solverResultTerm) = rr-lock-all-references(|analysis, solverResultTerm, <immap-new>)

  // Locks the reference represented by the given term
  // if the reference has a @ref property, or fails if it is not a reference.
  // The map contains a mapping from the original term index to the new term index, if applicable.
  rr-lock-one-reference(|analysis, solverResultTerm, map): ref -> lockedRef
  where (_, sortName) := <rr-get-ref-name> ref;			// Fails if the term is not a valid reference
  		decl := <rr-get-ref-decl(|analysis, map)> ref;	// Fails if the term does not have an @ref property
        where(<debug(!"Accept Decl: ")> decl);
        lockedRef := <rr--lock-reference(|decl, solverResultTerm, sortName)> ref;
        where(<debug(!"Locked: ")> lockedRef)
        
  // If the term is a valid reference, returns the name and the sort name; otherwise, fails.
  rr-get-ref-name: LValue2Exp(Var2LValue(Var(name))) -> (name, "Exp")
  // If the term is a valid reference, returns the term index; otherwise, fails.
  rr-get-ref-index: LValue2Exp(Var2LValue(Var(name))) -> <stx--get-ast-index> name
  // If the term is a valid reference, returns the value of the @ref property, if any; otherwise, fails.
  rr-get-ref-decl(|analysis, map) = rr-get-ref-index; try(<immap-get(|<id>)> map); stx--get-ast-property-from-index(|analysis, Ref())
  
  
  // For each term in the subtree, replace the existing term index with a new term index (starting at `startIndex`).
  // Returns a tuple of the new term and a map mapping the original indices to the new indices.
  // Terms that did not have an original index are not in the resulting map.
  rr-reindex(|startIndex): t -> (t', map)
  where (t', map) := <stx--reindex-ast(|"", startIndex); debug(!"Reindexed: ")> t
        //t'' := <rr-adjust-locked-references(|map); debug(!"Refs adjusted: ")> t'
  
  // Attempts to fix each locked refence according to the given map
  //rr-adjust-locked-references(|map) = bottomup(try(rr--adjust-locked-reference(|map)))
  
  
  rules
    rr--lock-reference(|decl, solverResultTerm, sortName) = prim("RR_lock_reference", decl, solverResultTerm, sortName)
    rr--create-placeholder(|contexts) = prim("RR_create_placeholder", contexts)
    rr--fix-references(|solverResultTerm) = prim("RR_fix_references", solverResultTerm) 
    rr--adjust-locked-reference(|map) = prim("RR_adjust_locked_reference", map) 

