module refret

imports
  strategolib
  //signatures/Tiger-sig
imports
  libspoofax/analysis/constraint
  statix/runtime/analysis
  statix/runtime/ast
  
  signatures/syntax/Arrays-sig
  signatures/syntax/Base-sig
  signatures/syntax/Bindings-sig
  signatures/syntax/Control-Flow-sig
  signatures/syntax/Functions-sig
  signatures/syntax/Identifiers-sig
  signatures/syntax/Numbers-sig
  signatures/syntax/Records-sig
  signatures/syntax/Strings-sig
  signatures/syntax/Types-sig
  signatures/syntax/Variables-sig
  signatures/syntax/Whitespace-sig
  
imports //construct-textual-change
  libstratego-gpp
  libspoofax/sdf/pp
  libspoofax/editor/refactoring/-
  pp/tiger-parenthesize
  pp

strategies

  construct-textual-change = construct-textual-change(pp-partial-tiger-string, parenthesize, override-reconstruction, resugar)

  inline-method-call(|call@Call(name, args), solverResultTerm): ast -> fixedAst
  where where(<debug(!"Call: ")> call);
        analysis := <stx--get-ast-analysis> ast;
        decl := <stx--get-ast-property(|analysis, Ref())> name;
        fun@FunDec(fname, fparams, fretType, fbody) := <collect(?FunDec(_,_,_,_)|decl)> ast;
        where(<debug(!"Inlining: ")> fun);
        argvars := <zip(?(FArg(pn, pty), ae); !VarDec(pn, pty, ae))> (fparams, args);
        newbody := <rr-lock-all-references(|solverResultTerm)> fbody;
        ctxs := <build-contexts(|call, solverResultTerm)> ast;
        plhdrbody := <prim("RR_create_placeholder", ctxs)> newbody;
        replacement := Let(argvars, [ plhdrbody ]);
        newAst := <replace(!replacement|call)> ast;
        where(<debug(!"Pre-RR: ")> newAst);
        fixedAst := <prim("RR_fix_references", solverResultTerm)> newAst
        // TODO: RR
        //text := <construct-textual-change> (ast, <replace(!Let(argvars, [ fbody ])|call)> ast);
        //where(<debug(!"Text: ")> text)
        
        
   build-contexts(|call@Call(_, _), solverResultTerm): ast -> [] // Not sure what contexts we could provide here
   
        
   // Finds the declaration term corresponding to the specified declaration
   // (that was retrieved from the @ref attribute of a reference)
   collect(s|decl) =
     where(idx := <stx--get-ast-index> decl);
     collect-onebu(s; has-index(|idx))
     
   // Replaces a term in the ast that matches the given term and its index
   // by applying strategy s to it
   replace(s|term) =
     where(idx := <stx--get-ast-index> term);
     oncebu(?term; where(stx--get-ast-index; ?idx); s)
   
   // Succeeds if the term has a subterm with the specified index
   has-index(|idx): term -> term
   where oncetd(stx--get-ast-index; ?idx)
  
//  where where(<debug(!"Inlining call: ")> call);
//        where(<debug(!"Call: ")> call);
//        analysis := <stx--get-ast-analysis> ast;
//        decl := <stx--get-ast-property(|analysis, Ref())> call;
//        where(<debug(!"Decl: ")> decl);
//        //prim("RR_create_placeholder", ["abc"]);
//        //prim("RR_fix_references", analysis);
//        lockedRef := <prim("RR_lock_reference", decl, solverResultTerm)> call;
//        where(<debug(!"Locked Ref: ")> lockedRef);
//        newAst := ast;	// TODO
//        debug(!"Inlined: ")

  // Collect bottomup the first term where strategy `s` succeeds; or fails if there is no such term
  collect-onebu(s) = oncebu(where(s; ?t)); !t

  // Locks all references in the given term
  rr-lock-all-references(|solverResultTerm) = bottomup(try(rr-lock-one-reference(|solverResultTerm)))

  // Locks the reference represented by the given term
  // if the reference has a @ref property, or fails if it is not a reference.
  rr-lock-one-reference(|solverResultTerm): ref -> lockedRef
  with  analysis := <stx--get-ast-analysis> ref
  where //where(<debug(!"Try: ")> ref);
        decl := <stx--get-ast-property(|analysis, Ref())> ref;
        where(<debug(!"Accept Decl: ")> decl);
        lockedRef := <prim("RR_lock_reference", decl, solverResultTerm)> ref;
        where(<debug(!"Locked: ")> lockedRef)


