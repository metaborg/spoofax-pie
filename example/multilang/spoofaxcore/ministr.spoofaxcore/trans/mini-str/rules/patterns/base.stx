module mini-str/rules/patterns/base

imports
  cons-type-interface/types
  cons-type-interface/sorts
  cons-type-interface/constructors

  signatures/mini-str/mini-str-sig
  mini-str/rules/resolution
  mini-str/rules/list-sorts
  mini-str/rules/variables
  mini-str/pattern-type

rules

  arityOfCons : list(Pattern) -> int

  arityOfCons([]) = 0.
  arityOfCons([_]) = 1.
  arityOfCons([h | t]) = res :- {ts}
    ts == arityOfCons(t),
    res #= ts + 1.

rules

  ptrnsOk maps ptrnOk(*, *, list(*), list(*))
  lptrnOk maps ptrnOk(*, *, list(*), *)

  ptrnOk : scope * PATTERN * Pattern * TYPE

  ptrnOk(s, pt, Constr(n, p), T) :- {T1 T2 n' n1 n2}
    typeOfCons(s, arityOfCons(p), n) == CONS(T1, T2, _, _),
    ptrnsOk(s, pt, p, T2),
    nameOfSort(T1) == n1,
    nameOfSort(T) == n',
    typeEq(T, T1)
    | error $[Expected constructor of sort [n'], but was [n1]] @n.

  ptrnOk(s, pt, l@List(i), T) :- {T1 Tc n1 n}
    typeOfContent(T) == Tc,
    typeOfList(l, Tc) == T1,
    typeEq(T1, T)
    | error $[Expected list of type [n], but was [n1]],
    nameOfSort(T1) == n1,
    nameOfSort(T) == n,
    lptrnOk(s, pt, i, Tc).

  ptrnOk(s, pt, c@RuleCall(n, op), T) :- {T1 T2}
    resolveRule(s, n) == RULE(T1, T2),
    ptrnOk(s, pt, op, T1),
    typeEq(T, T2).

  ptrnOk(s, MATCH(), Var(n), T) :-
    declareVar(s, n, T).

  ptrnOk(s, BUILD(), Var(n), T) :- {T1 n' n1}
    typeOfVar(s, n) == T1,
    nameOfSort(T1) == n1,
    nameOfSort(T) == n',
    typeEq(T1, T) | error $[Expected variable of sort [n'], but was [n1]] @n.

