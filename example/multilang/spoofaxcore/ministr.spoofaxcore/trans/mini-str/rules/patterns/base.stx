module mini-str/rules/patterns/base

imports
  cons-type-interface/types
  cons-type-interface/sorts
  cons-type-interface/constructors

  signatures/mini-str/mini-str-sig
  mini-str/rules/resolution
  mini-str/rules/list-sorts
  mini-str/rules/variables
  mini-str/pattern-type

rules

  arityOfCons : list(Pattern) -> int

  arityOfCons([]) = 0.
  arityOfCons([_]) = 1.
  arityOfCons([h | t]) = res :- {ts}
    ts == arityOfCons(t),
    res #= ts + 1.

rules

  ptrnsOk maps ptrnOk(*, *, list(*), list(*))
  lptrnOk maps ptrnOk(*, *, list(*), *)

  ptrnOk : scope * PATTERN * Pattern * TYPE

  ptrnOk(s, pt, Constr(n, p), T) :- {T1 T2}
    typeOfCons(s, arityOfCons(p), n) == CONS(T1, T2, _, _),
    ptrnsOk(s, pt, p, T2),
    typeEq(T, T1)
        | error $[Expected constructor of sort [T], but was [T1]] @n.

  ptrnOk(s, pt, l@List(i), T) :- {T1}
    typeOfList(l) == T1,
    typeEq(T1, T),
    lptrnOk(s, pt, i, typeOfContent(T)).

  ptrnOk(s, pt, c@RuleCall(n, op), T) :- {T1 T2}
    resolveRule(s, n) == RULE(T1, T2),
    ptrnOk(s, pt, op, T1),
    typeEq(T, T2).

  ptrnOk(s, MATCH(), Var(n), T) :-
    declareVar(s, n, T).

  ptrnOk(s, BUILD(), Var(n), T) :- {T1}
    typeOfVar(s, n) == T1,
    typeEq(T, T1) | error $[Expected variable of sort [T], but was [T1]] @n.
