module mini-str/rules/resolution

imports
  cons-type-interface/sorts
  cons-type-interface/labels
  mini-str/rules/list-sorts

signature

  sorts RTDECL = (path * (occurrence * RTYPE))
  sorts RTYPE constructors
    // Rule type: input sort -> output sort
    RULE : TYPE * TYPE -> RTYPE

  namespaces
    RuleInst : string 	// Declaration of single rewrite rule
    Rule : string  		// Module-unique declaration of rule

  name-resolution
    labels S

    resolve RuleInst
      filter S+ // Only find rule instances in same module

    resolve Rule
      filter P* I*
      min $ < P, $ < I, P < I

  relations
    ruleInstType: occurrence -> RTYPE
    ruleType: occurrence -> RTYPE

  // Sort used for prettyfying names
  sorts SNAME constructors
    Raw       : string -> SNAME // raw
    Opt  	  : string -> SNAME // optional
    Iter      : string -> SNAME // iter
    Star      : string -> SNAME // star
    Single    : string -> SNAME // singleton list
    Multi     : string -> SNAME // list with multiple elements
    Empty     : SNAME 			// empty list

rules

  // Declares a single rule instance in a scope
  declareRule : scope * scope * string * TYPE * TYPE

  declareRule(s, s_seq, n, T1, T2) :- {rls rt rts rits}
    rt == RULE(T1, T2),
    ruleInstType of RuleInst{n} in s_seq |-> rits,
    query ruleType
      filter resolveMatch[Rule{n}] & ~e and { t :- t == Rule{n} }
      in s |-> rts,
    declRule(s, s_seq, rts, rits, n, rt).

rules

  declRule: scope * scope * list(RTDECL) * list(RTDECL) * string * RTYPE

  // Rule definition is valid when no parent rule specified
  declRule(s_mod, s_seq, [], [], n, T) :-
    s_mod -> Rule{n} with ruleType T,
    s_seq -> RuleInst{n} with ruleInstType T.

  declRule(s_mod, s_seq, [(_, (_, T_decl)) | _], _, n, T) :-
    equitype(T_decl, T).

  // Rule definition is valid when it complies with parent
  declRule(s_mod, s_seq, [], [(_, (_, T_decl)) | _], n, T) :-
    equitype(T_decl, T).

rules
  equitype : RTYPE * RTYPE

  equitype(RULE(T1, T2), RULE(T3, T4)) :- {n1 n2 n3 n4}
    nameOfSort(T1) == n1,
    nameOfSort(T2) == n2,
    nameOfSort(T3) == n3,
    nameOfSort(T4) == n4,
    T1 == T3 | error $[Input type [n3] does not match with specified type [n1]],
    T2 == T4 | error $[Output type [n4] does not match with specified type [n2]].

rules

  namesOfRules maps nameOfRule(list(*)) = list(*)

  nameOfRule : (path * (occurrence * RTYPE)) -> string
  nameOfRule((_, (RuleInst{n}, _))) = n.
  nameOfRule((_, (Rule{n}, _))) = n.

rules

  typesOfRules maps typeOfRule(list(*)) = (list(*), list(*))

  typeOfRule: (path * (occurrence * RTYPE)) -> (TYPE * TYPE)
  typeOfRule((_, (_, RULE(T1, T2)))) = (T1, T2).

rules

  uniqType: list(TYPE) -> list(TYPE)

  uniqType([]) = [].
  uniqType([h | t]) = [h | uniqType(removeType(h, t))].

rules

  removeType: TYPE * list(TYPE) -> list(TYPE)

  removeType(_, []) = [].
  removeType(s, [s | l]) = removeType(s, l).
  removeType(s1, [s2 | l]) = [s2 | removeType(s1, l)] :-
    s1 != s2.

rules

  resolveRule : scope * string -> RTYPE

  resolveRule(s, n) = R :-
    ruleType of Rule{n} in s |-> [(_, (_, R)) | _].

rules

  nameOfSortI: TYPE -> string
  nameOfSortI(TSORT(_, n)) = n.
  nameOfSortI(TOPT(T)) = nameOfSortI(T).
  nameOfSortI(TSTAR(T)) = nameOfSortI(T).
  nameOfSortI(TITER(T)) = nameOfSortI(T).

  nameOfSorts maps nameOfSort(list(*)) = list(*)
  nameOfSort: TYPE -> SNAME

  nameOfSort(TSORT(_, n)) = Raw(n).
  nameOfSort(TOPT(T)) = Opt(nameOfSortI(T)).
  nameOfSort(TSTAR(T)) = Star(nameOfSortI(T)).
  nameOfSort(TITER(T)) = Iter(nameOfSortI(T)).
  nameOfSort(SINGLETON(T)) = Single(nameOfSortI(T)).
  nameOfSort(MULTI(T)) = Multi(nameOfSortI(T)).
  nameOfSort(EMPTY()) = Empty().
