module module-interface/modules

imports
  cons-type-interface/types
  cons-type-interface/labels
  
  cons-type-interface/conflicts/sorts
  cons-type-interface/conflicts/constructors

signature

  namespaces
    Module : string

  sorts MODULE constructors
    MODULE : scope * ModuleType -> MODULE

  sorts ModuleType constructors
    SUPPLY : ModuleType
    CONSUME : ModuleType
  
  relations
    modType : occurrence -> MODULE

  name-resolution
    resolve Module filter P*

rules

  // Rule used for validating unique import of sorts/conss/rules
  itemsOk: string * scope * scope

  itemsOk(_, s_imp, s_mod) :-
    sortsUnique(s_imp, s_mod),
    conssUnique(s_imp, s_mod).

rules

  declareMod: scope * string * scope * ModuleType

  declareMod(s, n, s_mod, T) :-
    s -> Module{n} with modType MODULE(s_mod, T),
    // Validate module name unique
    modType of Module{n} in s |-> [_]
      | error $[Module [n] declared multiple times].

rules

  import: scope * string * ModuleType -> scope

  import(s_imp, n, T) = s_mod :- {T1}
    s_imp -I-> s_mod,
    modType of Module{n} in s_imp |-> [(_, (_, MODULE(s_mod, T1))) | _]
        | error $[Module [n] could not be found],
    // Validate module type combination is correct.
    T1 == T | error $[Module of type [T] cannot import module of type [T1]],
    // Validate no comflicts in imported constructs
    itemsOk(n, s_imp, s_mod).
