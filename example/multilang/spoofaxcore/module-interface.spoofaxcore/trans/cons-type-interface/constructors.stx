module cons-type-interface/constructors

imports
  cons-type-interface/types
  cons-type-interface/labels

signature
  namespaces

    Cons : string

  relations

    cons: occurrence * int -> CONS

  name-resolution

    resolve Cons
      filter P* I* // Transitive imports. If not: sort of imported cons might not be found
      min $ < P, $ < I, P < I

rules

  declareCons : scope * TYPE * string * list(TYPE)

  declareCons(s, T, n, S) :- {a ctag}
    new ctag,
    a == arityOfSig(S),
    !cons[Cons{n}, a, CONS(T, S, a, ctag)] in s,
    // Check for constructors with same name in same scope
    query cons
      filter e and { t :- t == (Cons{n}, a) }
      in s |-> [_] | error $[Duplicate declaration of constructor [n]/[a].],
    // Check for constructors with same name in imported modules
    query cons
      filter resolveMatch[Cons{n}] & ~e and { t :- t == (Cons{n}, a) }
      in s |-> [] | error $[Shadowing imported constructor [n]/[a].].

rules

  typeOfCons : scope * int * string -> CONS

  typeOfCons(s, a, n) = C :-
    query cons
      filter P* I* and { t :- t == (Cons{n}, a) }
      in s |-> [(_, (_, _, C))| _]
      | error $[Constructor [n]/[a] not declared].

rules

  arityOfSig : list(TYPE) -> int

  arityOfSig([]) = 0.
  arityOfSig([_]) = 1.
  arityOfSig([h|t]) = res :- {ts}
    ts == arityOfSig(t),
    res #= ts + 1.
